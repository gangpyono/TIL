# 실행컨텍스트 : 실행할 코드에 제공할 환경 정보들을 모아놓은 객체.
- 최초에 자바스크립트엔진이 코드를 읽기시작하면 콜스택에 전역 컨텍스트를 담고 이를 활성화시킨다.
- 전역컨텍스트에 담긴 코드들을 실행 시키면서 함수 호출문을 만나게되면 해당 함수의 환경 정보를 수집해서 해당함수의 실행컨텍스트를 생성한후 콜 스택에 담는다.
- 이떄 콜스택 구조상 전역 컨텍스트 위에 방금 담겨진 실행컨텍스트가 담겼기때문에, 전역 컨텍스트를 중지시키고 해당 함수의 실행컨텍스트를 활성화시킨다.
  - 이를 코드작성관점에서 보면 전역에서 코드를 읽다가 해당함수 호출문을만나면 해당함수의내부 코드를 읽기시작한것과 동일.
- 실행 컨텍스트를 구성하는방법으로는 전역공간(최초 자바스크립트 파일실행), 함수실행 두가지만 생각.


## 실행컨텍스트는 무엇으로 구성되는가?(환경정보란?)
- VariableEnvironment
  - LexicalEnvironment와 같지만 실행 컨텍스트를 생성할떄 VariableEnvironment에 정보를 먼저만들고 이를 복사해서 LexicalEnvironment에 그대로 담음. 
  - 최초생성후 변경되지않는다. (스냅샷처럼 유지)
  - environmentRecord(snapshot) + outerEnvirmonmentReference(snapshot)로 구성
- LexicalEnvironment
  - VariableEnvironment의 복사본. 이후 실행 컨텍스트를 실행하면서 발생하는 변경사항이 여기에 반영됨.
- ThisBinding 


### 1.envirnmentRecord
- 현재 컨텍스트와 관련된 코드의 식별자 정보들이 저장된다.
- 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자
- 함수내에서 선언된 변수의 식별자
- 함수내에서 선언된 함수자체

  -> 위의 정보들을 컨텍스트 내부 전체를 처음부터 끝까지 훝어나가며 순서대로 수집함.
- 이 과정에서 호이스팅발생 


#### 호이스팅 
- 엔진의 실제 동작방식이 아닌, 단순히 실행된다는 관점에서만 봤을때 식별자들을 최상단으로 끌어올려놓은다음 코드를 실행한다 라고생각하기위해 생긴 가상의 개념.

#### 함수 선언문과 함수 표현식
- 함수 선언문 
```js
function a() {};
a() 실행 ok
```
- 함수 표현식
```js
var b = function() {};
b();
```
- 호이스팅시 둘의 차이점 
  - 함수 선언문은 함수 전체를 호이스팅하지만, 함수 표현식은 변수 선언부만 호이스팅함. 
  - 함수표현식을 사용함으로써, 함수도 하나의 값으로 취급할 수 있음을 의미. (함수를 변수에 값으로써 할당한다.)
  
    -> 따라서 함수 선언문에의해 선언된 함수는 선언전에 호출이 가능하다. (함수자체가 호이스팅이 발생함으로)
    
    
    -> 우리가 코드를읽는 순서(위에서 아래로)를 고려헀을떄 선언후에 호출하는것이 훨씬 자연스럽기떄문에 함수를 선언할떄 함수 표현식을 사용할 것.
    
  
### 2.스코프,스코프체인,outerEnvironmentReference
- 스코프 : 식별자에대한 유효범위. 
  - 어떤 경계A 외부에서 선언한 변수는 내부에서도 접근이 가능하지만, A내부에서 선언한 변수는 오직 내부에서만 사용해야함.
- 스코프 체인 : 식별자에대한 유효범위를 안에서부터 바깥으로 차례로 검색해 나가는것을 스코프 체인이라한다.
- outerEnvironmentReference : LexicalEnvironment의 두번쨰 수집 자료로써, 스코프 체인을 가능하게해줌.


#### 스코프 체인
- outerEnvironmentReference는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조.
- 전역에 A함수선언하고 A함수내부에 B함수를 선언한경우, B함수의 outerEnvironmentReference는 A함수의 LexicalEnvironment를 참조하고
  A함수의 outerEnvironmentReference는 전역의 LexicalEnvironment를참조
- 그렇게 한단계 위에부터 차례로 검색을 하기떄문에 무조건 스코프체인상 가장 먼저 발견된 식별자에만 접근이 가능하다.

  -> B함수영역에서 참조하는 식별자의 이름이 B에는없고 A와 전역에 동일한 변수명으로 선언이되어있다 가정하면, B함수내에선 무조건 A영역에 선언된 식별자를 참조할 수밖에없다. (변수 은닉화)




### 3.thisBinding 
- this로 지정된 객체가 저장된다.
- 실행 컨텍스트 활성화 당시 this가 지정되어있지않을경우 this는 전역객체가 저장됨.
- 함수를 호출하는 방법에따라 this에 저장되는대상이 달라진다.
- 자세한 내용은 3장에서.
