# 1. js는 싱글 쓰레드 언어.

  - js자체에는 멀티쓰레딩을 할 수 있는 방법은 없지만, js가 동작하는 브라우저엔 여러가지의 쓰레드가 들어있다. 따라서 브라우저, 즉 웹 API를 이용하면 멀티 쓰레딩이 가능하다.

    → 자바스크립트가 실행되는 런타임환경(실행환경)에서는 다양한 방식을 통해 멀티쓰레딩 같은 효과를 얻을 수 있다.

    → 또한 이벤트 루프를 통해 좀더 다양한 동작을 실행할 수가 있다.

  - 우리의 웹 어플리케이션이 브라우저에 올라가는순간 자바스크립트 엔진이 우리가 작성한 코드를 한줄씩 해석하고 실행한다.
  - 이전 프로세스 설명시 프로세스 안에 힙과 스택이 있듯, 자바스크립트 엔진에도 메모리 힙과 콜스택이 있다.
<img width="700" alt="메모리힙 ,콜스택" src="https://user-images.githubusercontent.com/58588011/118498906-6fc7ae00-b761-11eb-9465-579582364924.png">

<br/><br/>
<br/><br/>

## 1. 메모리 힙 
  - 변수를 선언하여 오브젝트,문자열,숫자 등을 할당하게되면 메모리힙에 저장된다. (구조적으로 저장이되는것이아닌 아무곳에나 저장이됨)\

<br/><br/>
<br/><br/>

## 2. 콜스텍 
  -  함수가 실행되는 순서에따라 차곡차곡 쌓임. (LIFO 구조)
  - 이후 함수가 모두 끝나면 원래 자리로 돌아가기 위해 쓰이는 자료구조중 하나.
  - 모든 프로세스나 쓰레드 안에는 각각 저마다의 콜스택을 가지고 있다.
       →일의 수행순서에대한 정보를 기억해야하기떄문.
  - 재귀함수를 이용하여 함수를 무한히 호출할경우 콜스택 사이즈를 초과할 수있기 때문에 재귀함수를 이용시 유의해야한다.
  - 콜스택에 등록된 함수는 끝날때까지 보장된다.
     → 함수가 실행되고있는 도중엔 태스크에 등록된 콜백함수를 불러오거나 콜스택에등록된 다른함수를 실행할 수없고 현재 수행중인 함수가 끝날때까지 이벤트루프가 콜스택에 대기.
  
 
<br/><br/>
<br/><br/>

# 2. 자바스크립트의 엔진과 웹 APIs(브라우저)

 <img width="700" alt="자바스크립트 런타임 환경" src="https://user-images.githubusercontent.com/58588011/118661257-ea5c0080-b829-11eb-84ed-d9a31845fb31.png">
 
 ## 1. 브라우저를 통해 등록된 api의 콜백함수는 어떻게 동작하는가?
  - 우리의 소스코드내에서작성한 함수가 웹api를 호출한다고 가정.  →  웹 api가 콜스택에 등록됨.
  - 콜스택에 등록된 웹api가 호출됨.
  - 이때 콜스택에서 웹 api가 사라지고 브라우저는 웹api에 등록된 콜백함수를 해당하는큐에다가 등록시킴.


 ### 1. Queue.
 
  - 자료구조중 하나.(FIFO: first in first out)
 
<br/><br/>
    #### 1). task Queue 

    - setTimeOut , event Listener, fetch 등에 등록된 콜백함수가 등록되는 Queue.
    - 테스크큐에 등록된 함수는 언제실행되는가?   이벤트루프에의해 콜스택으로 옮겨짐으로써 실행됨.
    - microtask queue에대비하여 한루프에 한개의 콜백함수만 옮김.

    #### 2). microtask Queue 

    - promise, mutation observer등에 등록된 콜백함수가 등록되는 Queue.
    - 이벤트루프가 돌떄 콜백함수가 존재하면, 모든 콜백함수가 없어질때까지 콜스택으로 옮김. (옮겨진 콜백함수가 종료될시 한개씩 옮김.)

        → 모든 콜백함수가 옮겨질때까지 이벤트루프가 microtask Queue에 머무른다.
    - microtask Queue에 이벤트 루프가 머무르는동안 또다른 콜백함수가 등록되었을시, 그 콜백함수도 콜스택으로 옮겨 실행함. 즉, microtask queue 가 텅텅빌때까지 이벤트루프는 micro Queue에 머무른다.

 <br/><br/>
 <br/><br/>
 
 ### 2. Render.

- 브라우저 내에서 주기적인 애니매이션등에의한 화면을 업데이트해줌. (렌더링발생)
- Request Animation Frame 라는 api존재.


  → 이 api를 통해 콜백을 등록해놓으면, Requset Animation Frame Queue에  차례대로 등록되고,  다음화면의 업데이트전에 콜백함수가 순서대로 실행된후 렌더링과정 실행( 마찬가지로 FIFO 구조)
 
 <br/><br/>
 <br/><br/>
 
### 3. Event Loop

- 콜스택과 큐를 주기적으로 감시함.
- 콜스택이 비어져있다면, 큐에있는 콜백함수를 옮겨줌.
- 콜스택에 함수가있다면, 그함수가 종료가될떄까지 그함수는 보장된다.( 이벤트루프가 콜스택에서 머무른다.)

    → 시간이 오래걸리는 함수를 작성할시, 화면의 업데이트가 늦어진다.

    → 끝나지않는 콜백함수를 등록할시 이벤트루프가 콜스택에서 머무르게되기떄문에 렌더링이 발생하지않아 

    사용자입장에서는 흔히말하는 렉이걸린 상황이된다.

- 브라우저는 사용자에게 1초에 60프래임으로 업데이트한내용을 보여주려함.  → 60fps(16.7ms)

    → 이말은 16.7ms안에 업데이트가 이루어져야 사용자가 화면을 자연스럽게 볼수있음을 의미.

    → 이벤트 루프가 한바퀴를 도는데 걸리는 시간은1ms도 걸리지않는다.

    → 따라서 한루프를 도는데 무조건 Render을 업데이트할 필요가 없음.

    → 브라우저마다 다르지만 대부분 16.7ms정도에 Render을 한번 업데이트시킴.
    
    
    
    

