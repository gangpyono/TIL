# HTTP 헤더 2 - 캐시와 조건부 요청.

## 캐시

- 브라우저의 쿠키 저장소처럼 브라우저에 캐시저장소가 존재하고 서버에 요청을 보낼때마다 캐시저장소를 조회한후 요청할 데이터가 조회된다면 캐시저장소에서 데이터를 가져온다.
- 응답 메세지의 헤더에 cache-control : max-age = 60(캐시가 유효한 시간) 필드값이 존재한다면 웹 브라우저는 응답의 데이터를 캐시로인식하고 브라우저의 캐시저장소에 저장시킨다.
- 이후 동일한 데이터를 요청할떄 캐시 저장소에있는 캐시의 유효기간을 확인후 요청을 보낼지말지를 결정한다.
  <br></br>
  <br></br>

## 캐시 미적용.

- 데이터가 변경되지 않았어도 네트워크를 통해서 데이터를 다운받아야 한다.
- 인터넷 네트워크는 매우 느리고 비싸다.
- 브라우저 로딩 속도가 느리다. -> 느린 사용자 경험을 제공한다.
  <br></br>
  <br></br>

## 캐시 적용.

<img width="753" alt="스크린샷 2022-01-18 오후 5 36 31" src="https://user-images.githubusercontent.com/58588011/149900516-596282d4-904b-4f1e-9325-e03a3b769ed8.png">

- 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
- 비싼 네트워크 비용을 줄일 수 있다.
- 브라우저의 로딩속도가 빠르다 -> 빠른 사용자 경험.
  <br></br>

### 캐시 유효기간이 만료 됬을떄

- 캐시에 저장되어있는 동일한 데이터에대해서 요청을 보냈을떄 유효기간이 만료되었다면 서버로부터 응답을 받고 캐시 유효기간을 갱신 시킨다.
  - 이떄 다시 네트워크를 통해 데이터를 다운받는과정이 발생.
  - 만약 새로받은 캐시가 기존의 캐시저장소에 저장되어있는 캐시와 비교했을떄 변경되지않았다면 굳이 새로 받아오지않고 유효기간만 초기화할 수 있다.
    - 클라이언트의 데이터와 서버의 데이터가 같다는 것을 확인할 수 있는 방법이 필요. -> 검증헤더 + 조건부 요청로 확인가능.
      <br></br>
      <br></br>

## 검증헤더 와 조건부 요청헤더

### 검증헤더

- 최초 요청시 응답 헤더 필드로써 받음.
- 캐시 데이터와 서버데이터가 같은지 검증하는 응답헤더
  - Last-Modified, ETag
    <br></br>

### 조건부 **요청** 헤더

- 검증 헤더로 조건에 따른 분기
- If-Modified-Since: Last-Modified 사용
- If-None-Match: ETag 사용
- 조건이 만족하면 200 OK로, 새로운 데이터를 저장.
- 조건이 만족하지 않으면 304 Not Modified로, 기존데이터 재활용.
  <br></br>

### 전체적인 통신 순서

- 최초 캐시데이터를 받아올떄 헤더에서 Last-Modified 필드(최종 수정 날짜)가 포함된 메세지를받는다. (혹은 ETag)
  - 이를 캐시저장소에 함께 저장시킨다.
- 이후 캐시유효기간이 초과하여 요청을 보냈을떄 헤더에 If-Modified-Since: Last-Modified 필드를 추가하여 요청을 보냄.(혹은 If-None-Match: ETag)
- 서버에서 If-Modified-Since: Last-Modified필드로 전달된 날짜를 확인후 동일하다면 헤더 메타 정보 + 빈 바디를 304상태코드와함께 전송함으로써 기존 캐시저장소에 존재하는 데이터를 재사용할것을 알려주고, 다르다면 새로운 데이터를 200상태코드와함께 응답해줌(조건부 요청).
  - 여기서 새로운 데이터를 보내지않음으로써 네트워크 자원을 절약할 수있게된다.
    <br></br>

### If-Modified-Since: Last-Modified 헤더필드의 단점

- 초단위 미만으로 캐시 조정이 불가능하다.
- 날짜 기반의 로직.
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우.
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우.
  - 예) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우.
    <br></br>

### If-None-Match : ETag 헤더필드 사용으로 해결.

- ETag(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠.
  - 예) ETag: "v1.0", ETag: "a2jiodwjekjl3"
- 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성).
  - 예) ETag: "aaaaa" -> ETag: "bbbbb"
- 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기!
- 캐시 제어 로직을 서버에서 완전히 관리.
- 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름)
  - 예) 서버는 배타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지.
  - 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신.
    <br></br>

### 캐시 제어 헤더

- Cache-Control : 캐시 제어(대부분 Cache-Control로 제어)
  - Cache-Control : max-age
    - 캐시 유효 시간, 초 단위
  - Cache-Control : no-cache
    - 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용
    - 조건부 요청으로 항상 확인후 사용
  - Cache-Control : no-store
    - 캐시를 사용하지 않음(메모리에서 사용하고 최대한 빨리 삭제)
    - 그러나 HTTP스펙이 모든 브라우저에대해 완벽하게 적용되지는 않는다.
    - 따라서 완벽하게 캐시를 적용하지 않으려면 추가적인 헤더를 적용해야한다.(아래 참고)
- Pragma : 캐시 제어 (하위 호환)
  - Pragma: no-cache
  - HTTP 1.0 하위 호환
- Expires : 캐시 유효 기간 (하위 호환)
  - 캐시 만료일 지정(하위 호환)
  - expires :Mon, 01 Jan 1990 00:00:00 GMT
  - 캐시 만료일을 정확한 날짜로 지정
  - HTTP 1.0 부터 사용
  - 지금은 더 유연한 Cache-Control: max-age 권장
  - Cache-Control: max-age와 함께 사용하면 Expires는 무시
    <br></br>
    <br></br>

## 프록시 캐시 서버

- 사용예 : AWS의 cloudFront.
- 원서버에 직접접근하지않고 데이터를 받아올 수 있게 해줌.
- 최초 요청시 원 서버로부터 프록시 캐시 서버로 데이터를 옮겨놓는다.(최초 요청은 느리다.)

프록시캐시 도입 전

<img width="500" alt="스크린샷 2022-01-19 오후 12 13 48" src="https://user-images.githubusercontent.com/58588011/150057160-8b74a9c6-e049-441a-b495-37770941d93d.png">

프록시 캐시 도입 후 첫요청

<img width="500" alt="스크린샷 2022-01-19 오후 12 14 11" src="https://user-images.githubusercontent.com/58588011/150057208-d250939c-548b-47a9-a7e5-fd30005f4764.png">

이후 요청

<img width="500" alt="스크린샷 2022-01-19 오후 12 31 24" src="https://user-images.githubusercontent.com/58588011/150058911-d38a722d-2a1f-42d3-bb9d-aca8777ae425.png">

- Cache-Control: public
  - 응답이 public 캐시에 저장되어도 됨
- Cache-Control: private
  - 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함(기본값)
    <br></br>
    <br></br>

## 캐시 무효화(확실한 방법) - 아래 항목들을 전부 추가해줘야 완벽히 캐시처리를 막을 수 있음.

- Cache-Control : no-cache,no-store,must-revalidate
  - must-revalidate
    - 캐시 만료후 최초 조회시 원 서버에 검증해야함.(만료가 되지않았다면 캐시를 사용)
    - 원 서버에 접근 할 수 없는경우 항상 오류를 발생시킴(504 Gateway Timeout)
- Pragma : no-chche
  - HTTP 1.0 하위 호환 위해.
    <br></br>

### no-cache vs must-revalidate

<img width="500" alt="스크린샷 2022-01-19 오후 12 09 04" src="https://user-images.githubusercontent.com/58588011/150056675-e6fbfbe9-e74b-4483-b0aa-4eca207668b0.png">

<img width="500" alt="스크린샷 2022-01-19 오후 12 09 22" src="https://user-images.githubusercontent.com/58588011/150056712-d3d750ed-6a6b-4dd2-bcaf-23e59213bd5d.png">

