# HTTP 헤더 2 - 캐시와 조건부 요청.

## 캐시

- 브라우저의 쿠키 저장소처럼 브라우저에 캐시저장소가 존재하고 서버에 요청을 보낼때마다 캐시저장소를 조회한후 요청할 데이터가 조회된다면 캐시저장소에서 데이터를 가져온다.
- 응답 메세지의 헤더에 cache-control : max-age = 60(캐시가 유효한 시간) 필드값이 존재한다면 웹 브라우저는 응답의 데이터를 캐시로인식하고 브라우저의 캐시저장소에 저장시킨다.
- 이후 동일한 데이터를 요청할떄 캐시 저장소에있는 캐시의 유효기간을 확인후 요청을 보낼지말지를 결정한다.
  <br></br>

## 캐시 미적용.

- 데이터가 변경되지 않았어도 네트워크를 통해서 데이터를 다운받아야 한다.
- 인터넷 네트워크는 매우 느리고 비싸다.
- 브라우저 로딩 속도가 느리다. -> 느린 사용자 경험을 제공한다.
  <br></br>

## 캐시 적용.

<img width="753" alt="스크린샷 2022-01-18 오후 5 36 31" src="https://user-images.githubusercontent.com/58588011/149900516-596282d4-904b-4f1e-9325-e03a3b769ed8.png">

- 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
- 비싼 네트워크 비용을 줄일 수 있다.
- 브라우저의 로딩속도가 빠르다 -> 빠른 사용자 경험.
  <br></br>

## 캐시 유효기간이 만료 됬을떄

- 캐시에 저장되어있는 동일한 데이터에대해서 요청을 보냈을떄 유효기간이 만료되었다면 서버로부터 응답을 받고 캐시 유효기간을 갱신 시킨다.
  - 이떄 다시 네트워크를 통해 데이터를 다운받는과정이 발생.
  - 만약 새로받은 캐시가 기존의 캐시저장소에 저장되어있는 캐시와 비교했을떄 변경되지않았다면 굳이 새로 받아오지않고 유효기간만 초기화할 수 있다.
    - 클라이언트의 데이터와 서버의 데이터가 같다는 것을 확인할 수 있는 방법이 필요. -> 검증헤더 + 조건부 요청로 확인가능.
      <br></br>

## 검증헤더 와 조건부 요청헤더

### 검증헤더

- 최초 요청시 응답헤더필드로써 받음.
- 캐시 데이터와 서버데이터가 같은지 검증하는 응답헤더
  - Last-Modified, ETag

### 조건부 **요청** 헤더

- 검증 헤더로 조건에 따른 분기
- If-Modified-Since: Last-Modified 사용
- If-None-Match: ETag 사용
- 조건이 만족하면 200 OK로, 새로운 데이터를 저장.
- 조건이 만족하지 않으면 304 Not Modified로, 기존데이터 재활용.

### 전체적인 통신 순서

- 최초 캐시데이터를 받아올떄 헤더에서 Last-Modified 필드(최종 수정 날짜)가 포함된 메세지를받는다. (혹은 ETag)
  - 이를 캐시저장소에 함께 저장시킨다.
- 이후 캐시유효기간이 초과하여 요청을 보냈을떄 헤더에 If-Modified-Since: Last-Modified 필드를 추가하여 보냄.(혹은 If-None-Match: ETag)
- 서버에서 Last-Modified필드로 전달된 날짜를 확인후 동일하다면 헤더 메타 정보 + 빈 바디를 304상태코드와함께 전송함으로써 기존 캐시저장소에 존재하는 데이터를 재사용할것을 알려주고, 다르다면 새로운 데이터를 200상태코드와함께 응답해줌(조건부 요청).
  - 여기서 새로운 데이터를 보내지않음으로써 네트워크 자원을 절약할 수있게된다.

### If-Modified-Since: Last-Modified 헤더필드의 단점

- 초단위 미만으로 캐시 조정이 불가능하다.
- 날짜 기반의 로직.
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우.
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우.
  - 예) 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우.

### If-None-Match : ETag 헤더필드 사용으로 해결.

- ETag(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠.
  - 예) ETag: "v1.0", ETag: "a2jiodwjekjl3"
- 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성).
  - 예) ETag: "aaaaa" -> ETag: "bbbbb"
- 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기!
- 캐시 제어 로직을 서버에서 완전히 관리.
- 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름)
  - 예) 서버는 배타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지.
  - 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신.
