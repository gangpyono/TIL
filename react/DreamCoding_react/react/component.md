# 컴포넌트
## 정의
- 한가지 기능을 수행하는 UI단위 (ex - 버튼컴포넌트, 게시물 컴포넌트 등)

## 특징 
- 독립적이며 재사용이 가능하다. ( 테스팅이 유용하다.)
- 클래스 or 함수를통해 만들수 있다.
- 작성할떄 최대한 독립적이고 재사용이 가능한 작은단위로 만들어 나갈것.
  <br></br>

## 종류
### 1) 클래스형 컴포넌트

   <img width="700" alt="클래스컴포넌트" src="https://user-images.githubusercontent.com/58588011/119258588-4bf2e500-bc05-11eb-85c0-4cc66fb2dce0.png">
    <br></br>
    
   - 리액트에서 제공하는 컴포넌트 클래스를 상속해서 만들 수있음. 
   - UI가 어떻게 표기 될 것인지 정의하는 render() 함수작성.
   - 컴포넌트 자체에서 this.state 멤버 변수에 오브젝트 형태로 데이터를 관리할 수 있다.
   - state가 변화할떄마다 render함수가 호출됨(렌더링 발생).
   - 계속 render함수가 호출이되어도 성능이 괜찮은 이유은, 리액트 내부에 가상의 VDOM이 존재하기 떄문.(바뀐 부분만 실제 dom에 적용되기떄문)
   - 라이프사이클 메서드를 사용할 수 있다.
    <br></br>

  ### 2) 함수형 컴포넌트

   <img width="292" alt="함수 컴포넌트" src="https://user-images.githubusercontent.com/58588011/120090674-4d5d6980-c13f-11eb-88b9-324e7bad4ed2.png">
   <br></br>
    
   - UI는 jsx를 return문에 작성.
   - 스테이트와 라이프사이클 메소드가 없음.
   - 리액트16.8버전부터는 리액트 훅(Hook)이 도입되어 state,라이프사이클 메소드를 사용할 수 있게됨.
   - 컴포넌트에서 관리하는 상태(state)가 없고 외부에서 전달받은 데이터(props)만 보여주면 되거나, 둘다없는 정적인 컴포넌트인 경우 사용.
  
  <br></br>

  ### Hook 
  - 클래스 컴포넌트에서만 이용이 가능했던 state와 라이플 싸이클 메서드들을 함수형 컴포넌트에서도 사용할수있게해줌.
   - 의문 1)  굳이 왜 리액트훅을 사용해서 함수형 컴포넌트에서 state,라이프사이클 메소드를 사용하려할까?

     -  공식문서에서 함수형을 더 권장한다.


     - 클래스가 다루기 어렵기떄문(this).
     
  - 의문 2)  그러면 함수형만 사용해도되나?
    - 정적인 데이터를 다룬다면 함수형컴포넌트.
    - 컴포넌트가 상태가 존재하고 그 상태에 따라 업데이트가 필요하다면 class 컴포넌트 or 함수형 컴포넌트 + Hook.
    -  훅 자체가 비교적 최근에 도입된 부분이기 때문에 클래스 컴포넌트로 만들어진 경우가 많고, 사용에 있어 팀마다 호불호가 갈리기 때문에 둘 다 배워놓으면 좋다.
<br></br>
 
  ### 클래스형 vs 함수형 

  - 클래스형 컴포넌트는 맴버 변수들이 최초에 한번만 만들어지고 이후에 렌더링이 발생할 상황이면 render함수만 호출되면서 한번 선언된 멤버변수의 재 정의가 발생하지않지만, 함수형 컴포넌트는 함수 자체임으로 호출이될떄마다(렌더링이 발생할 떄마다) 함수의 코드 블록이 다시 실행되고,그 안에 선언한 모든 로컬 변수들또한 다시 선언된다.

  #### 의문

- 그렇다면 함수형 컴포넌트에서 useState로 state를관리할시 함수가 호출될떄마다 계속 초기값으로 초기화가 되야하지않나?
  - useState는 리액트훅으로써 제공되는 API로, 리액트에서 따로 메모리에 저장하여 관리한다.

  - useRef또한 렌더링될때마다 새로운 주소값을 반환하는것이아닌, 리액트에서 따로 메모리에 저장하여 관리한다.

  - 사용자가 만든 함수또한 메모리에저장하여 시킬수있다.(useCallback활용)

  - 함수 자체를 props로 전달받을 때, 컴포넌트에 usememo를 적용하여도, 부모 컴포넌트에서 함수가 계속해서 새로 생성되어 전달된다면, 리렌더링이 발생하는 사이드 이펙트가 발생할 수 있다. (부모 컴포넌트에서 useCallback 훅을 이용하여 막을 수 있다.)



  
