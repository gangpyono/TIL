# 모든 아나그램 찾기(해쉬, 투포인터, 슬라이딩 윈도우)
- S문자열에서 T문자열과 아나그램이 되는 S의 부분문자열의 개수를 구하는 프로그램을 작성하시오.
- 아나그램 판별시 대소문자가 구분됩니다. 부분문자열은 연속된 문자열이여야 한다.
- S단어에 T문자열과 아나그램이 되는 부분문자열의 개수를 출력하시오.




## 풀이
```html
     <script>
            function solution(s, t){
                let answer=0;
                
                let arrayS =  s.split('');
                let arrayT = t.split('');
                console.log(arrayS);
                console.log(arrayT);

                while(arrayS.length >= 3){
                    let cnt = 0;
                    let sH = new Map();
                    for(let x of arrayT) {
                       
                        if(sH.has(x)) sH.set(x,sH.get(x)+1);
                        else sH.set(x,1);
                    }

                    for(let i = 0; i<arrayT.length; i++) {
                        if(!sH.has(arrayS[i]) || sH.get(arrayS[i]) === 0) break;
                        else sH.set(arrayS[i],sH.get(arrayS[i])-1);
                    }

                    for(let [key,value] of sH) {
                        if(value !== 0) break;
                        cnt++;
                    }

                    if(cnt ===  sH.size) answer++;


                    arrayS.shift();
                    console.log(arrayS);
                }

                return answer;
            }
            
            let a="bacaAacba";
            let b="abc";
            console.log(solution(a, b));
        </script>
```       


## 해설
```html
     <script>

            function compareMaps (map1,map2) {
                if(map1.size !== map2.size) return false;
                for(let [key,value] of map1) {
                    if(!map2.has(key) || map2.get(key) !== value ) return false;   // 조건이 헷갈리다면 각각의경우를 if문으로 작성후 OR문으로 묶을것.
                    
                }
                    return true;
            }

            function solution(s, t){
                let answer = 0;
                let tH = new Map();
                let sH = new Map();
                
                let lt = 0;
                for(x of t) {        
                    if(tH.has(x)) tH.set(x,tH.get(x)+1);        
                    else tH.set(x,1);
                } 

                let len = t.length-1;  // 비교후 빠질원소떄문
                for(let i = 0; i<len; i++) {     //최초로 비교할 해쉬맵생성
                    if(sH.has(s[i])) sH.set(s[i],sH.get(s[i]+1));
                    else sH.set(s[i],1);
                }
                
                for(let rt = len; rt<s.length; rt++) {
                    if(sH.has(s[rt])) sH.set(s[rt],sH.get(s[rt])+1);        
                    else sH.set(s[rt],1);

                    if(compareMaps(sH,tH)) answer++;

                    sH.set(s[lt],sH.get(s[lt])-1);      
                    if(sH.get(s[lt]) === 0) sH.delete(s[lt]);   
                    lt++;
                }

                return answer;
            }
            
            let a="bacaAacba";
            let b="abc";
            console.log(solution(a, b));
        </script>
```


### 시간복잡도를 고려하여 작성할것.
- 이중for문 최소화.
